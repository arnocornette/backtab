"""
This type stub file was generated by pyright.
"""

import functools
import unittest
from unittest import mock
from beancount import loader
from beancount.utils import encryption_test

__copyright__ = ...
__license__ = ...
TEST_INPUT = ...
def get_failing_plugin_module(exc_type): # -> type[PluginModule]:
    """Return a failing plugin module. For testing."""
    class PluginModule:
        ...
    
    

real_import_module = ...
def mock_import_module(exc_type, plugin_name): # -> type[PluginModule] | ModuleType:
    ...

class TestLoader(unittest.TestCase):
    def test_import_exception(self): # -> None:
        ...
    
    @mock.patch('importlib.import_module', side_effect=ValueError)
    def test_import_other_exception(self, _): # -> None:
        ...
    
    @mock.patch('importlib.import_module', functools.partial(mock_import_module, ValueError))
    def test_run_transformation_exception(self): # -> None:
        ...
    
    @mock.patch('importlib.import_module', functools.partial(mock_import_module, SystemExit))
    def test_run_transformation_systemexit(self): # -> None:
        ...
    
    def test_run_transformations(self): # -> None:
        ...
    
    def test_load(self): # -> None:
        ...
    
    def test_load_string(self): # -> None:
        ...
    
    def test_load_nonexist(self): # -> None:
        ...
    
    @mock.patch.dict(loader.RENAMED_MODULES, { "beancount.ops.auto_accounts": "beancount.plugins.auto_accounts" }, clear=True)
    @mock.patch('warnings.warn')
    def test_renamed_plugin_warnings(self, warn): # -> None:
        ...
    


class TestLoadDoc(unittest.TestCase):
    def test_load_doc(self): # -> None:
        ...
    
    @loader.load_doc()
    def test_load_doc_empty(self, entries, errors, options_map): # -> None:
        """
        """
        ...
    
    @loader.load_doc(expect_errors=True)
    def test_load_doc_plugin(self, entries, errors, options_map): # -> None:
        """
        plugin "beancount.does.not.exist"
        """
        ...
    
    def test_load_doc_plugin_auto_pythonpath(self): # -> None:
        ...
    


class TestLoadIncludes(unittest.TestCase):
    def test_load_file_no_includes(self): # -> None:
        ...
    
    def test_load_file_nonexist(self): # -> None:
        ...
    
    def test_load_file_with_nonexist_include(self): # -> None:
        ...
    
    def test_load_file_with_absolute_include(self): # -> None:
        ...
    
    def test_load_file_with_relative_include(self): # -> None:
        ...
    
    def test_load_file_with_multiple_includes(self): # -> None:
        ...
    
    def test_load_file_with_duplicate_includes(self): # -> None:
        ...
    
    def test_load_string_with_relative_include(self): # -> None:
        ...
    
    def test_load_file_return_include_filenames(self): # -> None:
        ...
    


class TestLoadIncludesEncrypted(encryption_test.TestEncryptedBase):
    def test_include_encrypted(self): # -> None:
        ...
    


class TestLoadCache(unittest.TestCase):
    def setUp(self): # -> None:
        ...
    
    def tearDown(self): # -> None:
        ...
    
    def test_load_cache(self): # -> None:
        ...
    
    def test_load_cache_moved_file(self): # -> None:
        ...
    
    @mock.patch('os.remove', side_effect=OSError)
    @mock.patch('logging.warning')
    def test_load_cache_read_only_fs(self, remove_mock, warn_mock): # -> None:
        ...
    
    @mock.patch('beancount.loader.PICKLE_CACHE_THRESHOLD', 0)
    @mock.patch.object(loader, 'load_file', loader.load_file)
    def test_load_cache_override_filename_pattern_by_env_var(self): # -> None:
        ...
    
    @mock.patch('beancount.loader.PICKLE_CACHE_THRESHOLD', 0)
    @mock.patch.object(loader, 'load_file', loader.load_file)
    def test_load_cache_override_filename_pattern_by_argument(self): # -> None:
        ...
    
    @mock.patch('beancount.loader.PICKLE_CACHE_THRESHOLD', 0)
    @mock.patch.object(loader, 'load_file', loader.load_file)
    def test_load_cache_disable(self): # -> None:
        ...
    


class TestEncoding(unittest.TestCase):
    def test_string_unicode(self): # -> None:
        ...
    
    def test_string_latin1(self): # -> None:
        ...
    


class TestOptionsAggregation(unittest.TestCase):
    def test_aggregate_operating_currencies(self): # -> None:
        ...
    


if __name__ == '__main__':
    ...
